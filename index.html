<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WIS (DP and Memoization)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://use.typekit.net/bci7mcd.css">
  
  

  <link rel="stylesheet" href="./css/main.css">

  <script type="module" src="./dist/index.js"></script>
</head>

<body>
  <main class="main">
    
    <div class="container">
      <header class="banner">
        <h1>
          Weighted Interval Scheduling (with Dynamic Programming and Memoization)
        </h1>
      </header>

      <div class="main-menu">
        <!-- <div class="aaa">
          <style>
            .aaa {
              position: relative;
              width: 320px;
              height: 320px;
              background-color: red;
              box-sizing: border-box;
              /* display: flex; */
              overflow: auto;
            }

            .chill {
              width: 40px;
              height: 40px;
              background-color: blue;

              margin-top: 640px;
              margin-left: 1000px;
            }
            
            .chill-2 {
              width: 40px;
              height: 40px;
              background-color: yellow;

              margin-top: 1280px;
              margin-left: 1280px;
            }
          </style>
          <div class="chill"></div>
          <div class="chill-2"></div>
        </div> -->

        <div class="constraint-text">
          <p>Maximum Jobs: <input type="number" class="fill--max-jobs" disabled></p>
          <p>Maximum Time: <input type="number" class="fill--max-time" disabled></p>
          <p>Maximum Weight: <input type="number" class="fill--max-weight" disabled></p>
        </div>
        
        <div class="forms-container">
          <div class="toggle-form-buttons">
            <button class="job-form__button job-form__button--toggle-form job-form__button--toggle-form--MI">Multi-input Form</button>
            <button class="job-form__button job-form__button--toggle-form job-form__button--toggle-form--TA">Text Input Form</button>
          </div>

          <form action="#" method="post" class="job-form job-form--multi-input" novalidate>
            
            <div class="job-form__add-job-buttons">
              <button type="button" class="job-form__button job-form__button--add">Add New Job</button>
              <button type="button" class="job-form__button job-form__button--randomize">Randomize</button>
            </div>
  
            <div class="job-form__jobs-rows">
              <template id="job-form__row-template">
                <fieldset class="job-form__row" data-index="X">
                  <legend class="job-form__job-letter">Job X</legend>
    
                  <div class="job-form__field">
                    <label class="job-form__label">
                      <span class="job-form__label-text">Enter Start Time:</span>
                      <input type="number" class="job-form__input job-form__input--startTime" name="startTime" value="2" min="0" max="11" size="1" required>
                    </label>
                    <span class="job-form__error job-form__error--startTime"></span>
                  </div>
    
                  <div class="job-form__field">
                    <label class="job-form__label">
                      <span class="job-form__label-text">Enter Finish Time:</span>
                      <input type="number" class="job-form__input job-form__input--finishTime" name="finishTime" value="9" min="0" max="11" size="1" required>
                    </label>
                    <span class="job-form__error job-form__error--finishTime"></span>
                  </div>
    
                  <div class="job-form__field">
                    <label class="job-form__label">
                      <span class="job-form__label-text">Enter Weight:</span>
                      <input type="number" class="job-form__input job-form__input--weight" name="weight" value="1" min="1" max="99" size="1" required>
                    </label>
                    <span class="job-form__error job-form__error--weight"></span>
                  </div>
  
                  <button class="job-form__button job-form__button--remove" type="button">X&ThinSpace;Remove Job</button>
                </fieldset>
              </template>
            </div>
  
            <button class="job-form__button job-form__button--submit">Generate Visualization</button>
  
          </form>

          <form action="#" method="post" class="job-form job-form--textarea wbfk-hidden" novalidate>
            <div class="job-form__textareas">
              <div class="job-form__user-textarea-container">
                <label class="job-form__label">
                  <span class="job-form__label-text">Enter Job List</span>
                  <textarea class="job-form__textarea job-form__textarea--user" name="jobTextarea" cols="64" rows="12"></textarea>
                </label>
                <span class="job-form__error job-form__error--textArea"></span>
              </div>
              <div class="job-form__example-textarea-container">
                <label class="job-form__label" disabled>
                  <span class="job-form__label-text">Example Input {startTime, finishTime, weight}</span>
                  <textarea class="job-form__textarea job-form__textarea--example" name="jobTextarea" cols="64" rows="12" disabled></textarea>
                </label>
              </div>
            </div>
            
  
            <button class="job-form__button job-form__button--submit">Generate Visualization</button>
          </form>
        </div>
        
      </div>

      <div class="visualization wbfk-hidden">
        <div class="data-display">
          <div class="text-boxes">
            <!-- Text box: Place-bars -->
            <div class="text-box-line-group text-box-line-group--place-bars">
              <div class="text-box text-box wbfk-hidden">
                <p class="text-box__paragraph text-box__paragraph--unorder">
                  These blue bars represent jobs A&mdash;<span class="fill--last-job-letter"></span>.
                  You can hover over them to view their stats if you wish (the bottom stats will be explained soon).
                  <br />
                  Let's place them on the time graph from top to bottom.
                </p>
                <p class="text-box__paragraph text-box__paragraph--unorder-2 wbfk-hidden">
                  Done. We just placed them on the graph in the order you initially defined the jobs, right?
                </p>
                <p class="text-box__paragraph text-box__paragraph--order wbfk-hidden">
                  Let's take them back off for a moment. The first step in the process is to sort them in order of finish time, so let's visualize that.
                  <br />
                  (The sorting method is irrelevant; let's assume that it uses Merge Sort)
                </p>
                <p class="text-box__paragraph text-box__paragraph--ordered wbfk-hidden">
                  Perfect, this will make it easier to visually understand which jobs are compatible with each other.
                  <br />
                  We can refer to each job by their <span class="SJ-related">sorted index</span>.
                  <span class="SJ-related">job 0</span> will be reserved as a non-existent job.
                </p>
              </div>
              <wbfk-connector class="wbfk-hidden"></wbfk-connector>
            </div>
  
            <div class="naive-algorithm-text">
              
            <!-- Text box: finished c-array -->
              <div class="text-box-line-group text-box-line-group--finished-c-array">
                <div class="text-box text-box wbfk-hidden">
                  <p class="text-box__paragraph text-box__paragraph">
                    Excellent, we've found every job's nearest <span class="c-related">compatible job</span>.
                    Our next step is to figure out the optimal (maximum) weight we can obtain from these jobs without having any of them overlap.
                  </p>
                </div>
                <wbfk-connector class="wbfk-hidden"></wbfk-connector>
              </div>
  
              <!-- Text box: show naive -->
              <div class="text-box-line-group text-box-line-group--show-naive">
                <div class="text-box text-box wbfk-hidden">
                  <p class="text-box__paragraph text-box__paragraph">
                    The naive or brute force approach would be to test every single combination of jobs, which could be done using this recursive algorithm
                    <br />
                    <span class="algorithm">
                      <span class="OPT-related">OPT(<span class="SJ-related">j</span>)</span> {
                        <br />
                        &emsp;if (<span class="SJ-related">j</span> = 0)
                          <br />
                            &emsp;&emsp;return 0;
                          <br />
                        &emsp;else
                          <br />
                          &emsp;&emsp;return max(<span class="algorithm__term-1"><span class="weight-related">w<sub><span class="SJ-related">j</span></sub></span>
                          + <span class="OPT-related">OPT(<span class="c-related">c[<span class="SJ-related">j</span>]</span>)</span></span>,
                          <span class="algorithm__term-2"><span class="OPT-related">OPT(<span class="next-SJ-num-expression"><span class="SJ-related">j</span>-1</span>)</span></span>);
                        <br />
                      }
                    </span>
                    <br />
                    (where <span class="weight-related">w</span> is <span class="weight-related">weight</span>)
                    and calling <span class="OPT-related">OPT(<span class="fill--last-SJ-num SJ-related">X</span>)</span>.
                  </p>
                </div>
                <wbfk-connector class="wbfk-hidden"></wbfk-connector>
              </div>
  
              <!-- Text box: explain naive 1 -->
              <div class="text-box-line-group text-box-line-group--explain-naive-1 line-front">
                <div class="text-box text-box wbfk-hidden">
                  <p class="text-box__paragraph text-box__paragraph">
                    This first term represents the possibility that the current <span class="SJ-related">job j</span> is indeed part of the optimal sequence of jobs.
                    Thus, it adds <span class="SJ-related">job j</span>'s <span class="weight-related">weight</span>,
                    and then it adds whatever the optimal weight is from the chain starting at job <span class="c-related">c[<span class="SJ-related">j</span>]</span>.
                    <br />
                    Why? Because if <span class="SJ-related">job j</span> is part of the optimal chain, then the latest preceding job that could
                    possibly also be in the chain is one that doesn't overlap, i.e. <span class="SJ-related">job j</span>'s nearest <span class="c-related">compatible job</span>.
                  </p>
                </div>
                <wbfk-connector class="wbfk-hidden"></wbfk-connector>
              </div>
  
              <!-- Text box: explain naive 2 -->
              <div class="text-box-line-group text-box-line-group--explain-naive-2 line-front">
                <div class="text-box text-box wbfk-hidden">
                  <p class="text-box__paragraph text-box__paragraph">
                    This second term represents the possibility that <span class="SJ-related">job j</span> is NOT part of the optimal sequence of jobs. Thus, of course,
                    <span class="SJ-related">job j</span>'s <span class="weight-related">weight</span> is NOT added, and it then computes the optimal weight starting from
                    the job behind it, <span class="SJ-related">job j</span> - 1.
                  </p>
                </div>
                <wbfk-connector class="wbfk-hidden"></wbfk-connector>
              </div>
  
              <!-- Text box: explain naive bad -->
              <div class="text-box-line-group text-box-line-group--explain-naive-bad">
                <div class="text-box text-box wbfk-hidden">
                  <p class="text-box__paragraph text-box__paragraph">
                    The problem with the naive approach is that it may recompute many overlapping subproblems.
                    In other words, we might solve the same <span class="OPT-related">OPT(X)</span> multiple times, which is incredibly inefficient.
                  </p>
                </div>
                <wbfk-connector class="wbfk-hidden"></wbfk-connector>
              </div>
            </div>
          </div>
  
          <div class="time-graph">
  
            <wbfk-connector class="c-related wbfk-hidden" b-marker></wbfk-connector>
            <div class="time-graph__c-bar wbfk-hidden"></div>
            
            <div class="time-graph__job-bars">
              <template id="time-graph__job-bar-template">
                <div class="time-graph__job-bar" data-jobletter="X">X</div>
              </template>
            </div>
            
            <div class="time-graph__rows">
              <template id="time-graph__row-template">
                <div class="time-graph__row">
                  <div class="time-graph__cell time-graph__cell--header">
                    <span class="time-graph__SJ-num SJ-num wbfk-hidden">(j=X)</span>
                    <span class="time-graph__job-letter time-graph__job-letter--unsorted" >Job X</span>
                    <span class="time-graph__job-letter time-graph__job-letter--sorted wbfk-hidden">Job X</span>
                  </div>
                </div>
              </template>
              
              <div class="time-graph__row time-graph__row--times">
                <div class="time-graph__cell time-graph__cell--header">Time</div>
                <!-- <div class="time-graph__cell time-graph__cell--0"><span>0</span></div> -->
              </div>
            </div>
  
          </div>
  
          <div class="array-groups">
            <template id="array__array-block-template">
              <div class="array__array-block">
                <span class="array__array-entry--blank">_</span>
                <span class="array__array-entry--value wbfk-hidden">X</span>
              </div>
            </template>
            <div class="array-group array-group--j-and-c">
              <div class="array array--j wbfk-hidden">
                <div class="array__array-block array__array-block--header">j</div>
              </div>
    
              <div class="array array--c wbfk-hidden">
                <div class="text-boxes">
                  <!-- Text box: c-array -->
                  <div class="text-box-line-group text-box-line-group--c-array c-related">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--explain">
                        Next, we will find each job's nearest <span class="c-related">"compatible"</span> job.
                        <!-- <br /> -->
                        For a job <span class="SJ-related">J<sub>x</sub></span>, another job <span class="c-related">J<sub>y</sub></span> is
                        <span class="c-related">compatible</span> with <span class="SJ-related">J<sub>x</sub></span> if
                        <span class="c-related">J<sub>y</sub>.finish</span> &leq; <span class="SJ-related">J<sub>x</sub>.start</span>.
                        That is to say, <span class="c-related">J<sub>y</sub></span> ends before or as soon as
                        <span class="SJ-related">J<sub>x</sub></span> begins.
                        <br /> Thus, <span class="SJ-related">J<sub>x</sub></span>'s NEAREST compatible job will be
                        <span class="c-related">J<sub>y</sub></span> such that <span class="c-related">y</span> is maximized.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--ref-array wbfk-hidden">
                        This green <span class="c-related">c array</span> to the left will be used to store the index of
                        each job's <span class="c-related">compatible job</span>.
                        If a job does not have a <span class="c-related">compatible job</span>,
                        we will give its <span class="c-related">c array</span> entry the value 0.
                        <br />
                        Now, let's begin.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
                  <!-- Text box: fill c-array -->
                  <div class="text-box-line-group text-box-line-group--fill-c-array c-related">
                    <div class="text-box text-box wbfk-hidden">
                      <template id="fill-c-array-paragraphs-template">
                        <p class="text-box__paragraph text-box__paragraph--for-job-X wbfk-hidden">
                          Let's find the nearest <span class="c-related">compatible job</span>
                          for <span class="SJ-related">job <span class="fill--curr-SJ-num">X</span></span>,
                          which starts at time <span class="fill--curr-start-time">X</span>.
                         </p>
                         <p class="text-box__paragraph text-box__paragraph--result-job-X wbfk-hidden">
                           After scanning the list, we see that <span class="fill--result-compatible-job-text"></span>
                           Therefore, <span class="c-related">c[<span class="SJ-related fill--curr-SJ-num">X</span>]</span> =
                           <span class="c-related fill--curr-c-entry"></span>.
                           Let's fill in <span class="c-related">c[<span class="SJ-related fill--curr-SJ-num">X</span>]</span>.
                         </p>
                      </template>
                      <p class="text-box__paragraph text-box__paragraph--continue-on wbfk-hidden">
                        Perfect, let's continue.
                      </p>
                    </div>

                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                </div>
  
                <div class="array__array-block array__array-block--header">c[j]</div>
              </div>
            </div>
  
            <div class="array-group array-group--j-and-M">
              <div class="array array--j wbfk-hidden">
                <div class="array__array-block array__array-block--header">j</div>
              </div>
    
              <div class="array array--M wbfk-hidden">
                <div class="text-boxes">
                  <!-- Text box: M-array -->
                  <div class="text-box-line-group text-box-line-group--M-array M-related">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--explain">
                        The solution is actually simple: Every time we find the optimal weight for a sequence from time 0 to some job, let's store it in an array.
                        Then, every time we call <span class="OPT-related">OPT(<span class="SJ-related">j</span>)</span>
                        for some job <span class="SJ-related">j</span>, we first check if it has already been solved by looking in the array.
                        <br />
                        This act of storing results in a table to prevent needless recalculations is called <span class="M-related">memoization</span>.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--ref-array wbfk-hidden">
                        This purple <span class="M-related">M array</span> to the left will be used as our memoization table; it will store the result of
                        each job's <span class="OPT-related">OPT()</span> computation.
                        If we have 0 jobs, of course the optimal weight would be 0, so our base case is that <span class="M-related">M[0]</span> = 0.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
                  <!-- Text box: show memoized algorithm -->
                  <div class="text-box-line-group text-box-line-group--show-memoized">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph">
                        Our new <span class="M-related">memoized</span> weighted interval scheduling algorithm looks like this:
                        <br />
                        <span class="algorithm">
                          <span class="OPT-related">OPT(<span class="SJ-related">j</span>)</span> {
                            <br />
                            &emsp;if (<span class="M-related">M[<span class="SJ-related">j</span>]</span> = empty)
                              <br />
                                &emsp;&emsp;<span class="M-related">M[<span class="SJ-related">j</span>]</span> := max(<span class="algorithm__term-1"><span class="weight-related">w<sub><span class="SJ-related">j</span></sub></span>
                                + <span class="OPT-related">OPT(<span class="c-related">c[<span class="SJ-related">j</span>]</span>)</span></span>,
                                <span class="algorithm__term-2"><span class="OPT-related">OPT(<span class="next-SJ-num-expression"><span class="SJ-related">j</span>-1</span>)</span></span>);
                              <br />
                            &emsp;return <span class="M-related">M[<span class="SJ-related">j</span>]</span>
                            <br />
                          }
                        </span>
                        <br />
                        Let's go ahead and call <span class="OPT-related">OPT(<span class="SJ-related fill--last-SJ-num">X</span>)</span>
                        and find the maximum weight we can achieve from jobs A&mdash;<span class="fill--last-job-letter">X</span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                </div>
                <div class="array__array-block array__array-block--header">M[j]</div>
              </div>
            </div>
          </div>

          <div class="data-display__right-border wbfk-hidden"></div>
        </div>
        
  
        <div class="job-cards">
          <template id="job-card-template">
            <div class="job-card wbfk-hidden" data-cardnum="X">
  
  
              <!--**************** CONTENT ****************-->
              <div class="job-card-content">
                <!-- TEXT BOXES -->
                <div class="text-boxes">
                  <!-- Text box: M Access -->
                  <div class="text-box-line-group text-box-line-group--M-access M-related">
                    <div class="text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--intro">
                        We need to know the optimal weight from time 0 through <span class="SJ-related">job <span class="SJ-num">X</span></span>.
                        First, let's check the <span class="M-related">M array</span> to see if it has already been computed.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--solved wbfk-hidden">
                        Excellent, this is the last finishing job, so we are finished.
                        The optimal weight we can achieve from our time graph is <span class="fill--comp-final">X</span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                  
                  <!-- Text box: Formula container -->
                  <div class="text-box-line-group text-box-line-group--formula-computation">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--find">
                        The entry is blank, so we need to compute the optimal weight ourselves using this equation.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--max wbfk-hidden">
                        We have computed both possibilities. Now we can compute the maximum.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--found wbfk-hidden">
                        The greater result was <span class="fill--comp-final">X</span>. Thus, the optimal weight from the beginning through
                        <span class="SJ-related">job <span class="SJ-num">X</span></span> is <span class="fill--comp-final">X</span>.
                        Let's assign it to <span class="M-related">M[<span class="SJ-num">X</span>]</span>
                        and fill in the entry in the <span class="M-related">M array</span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                  
                  <!-- Text box: Computation 1 -->
                  <div class="text-box-line-group text-box-line-group--computation--1">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--intro">
                        This first expression assumes that <span class="SJ-related">job <span class="SJ-num">X</span></span> IS part of the optimal chain of jobs.
                        It adds this job's <span class="weight-related">weight <span class="fill--weight">X</span></span>
                        and then computes from the best <span class="c-related">compatible job</span>.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--summary wbfk-hidden">
                        Let's summarize: If <span class="SJ-related">job <span class="SJ-num">X</span></span> is part of the optimal solution, then the maximum weight from
                        the beginning through <span class="SJ-related">job <span class="SJ-num">X</span></span> is <span class="fill--comp-1">X</span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
  
                  <!-- Text Box: c Access -->
                  <div class="text-box-line-group text-box-line-group--c-access c-related">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--find">
                        We need to find the optimal substructure starting from this job's compatible job.
                        Let's look at the <span class="c-related">c array</span> to get the job number.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--found wbfk-hidden">
                        The <span class="c-related">compatible job</span> was <span class="c-related">job <span class="fill--c-entry">X</span></span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
                  <!-- Text Box: OPT 1 -->
                  <div class="text-box-line-group text-box-line-group--OPT-expression-1 OPT-related">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--find">
                        Thus we will compute the total weight from the optimal substructure from time 0 through
                        <span class="c-related">job <span class="fill--c-entry">X</span></span>.
                        Let's do that now.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--found wbfk-hidden">
                        The optimal weight from the beginning through <span class="c-related">job <span class="fill--c-entry">X</span></span> was <span class="fill--OPT-1">X</span>.
                        Let's add this to <span class="SJ-related">job <span class="SJ-num">X</span></span>'s <span class="weight-related">weight <span class="fill--weight">X</span></span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
  
                  <!-- Text Box: Computation 2 -->
                  <div class="text-box-line-group text-box-line-group--computation--2">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph--intro">
                        This second expression assumes that <span class="SJ-related">job <span class="SJ-num">X</span></span> is NOT part of the optimal sequence.
                        It computes from the job right behind this one since it doesn't need to worry about overlap.
                      </p>
                      <p class="text-box__paragraph--summary wbfk-hidden">
                        Let's summarize: If <span class="SJ-related">job <span class="SJ-num">X</span></span> is NOT part of the optimal solution,
                        then the maximum weight from the beginning through
                        <span class="SJ-related">job <span class="SJ-num">X</span></span> is <span class="fill--comp-2">X</span>.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
  
                  <!-- Text Box: OPT 2 -->
                  <div class="text-box-line-group text-box-line-group--OPT-expression-2 OPT-related">
                    <div class="text-box text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--find">
                        <span class="SJ-num">X</span>-1 is <span class="fill--next-SJ-num">X</span>.
                        So we need to compute the weight from the optimal substructure starting at job <span class="fill--next-SJ-num">X</span>.
                        Let's do that now.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                </div>
  
                <!-- Connector for M array block -->
                <wbfk-connector class="connector--M-access-to-M-block M-related wbfk-hidden" b-marker></wbfk-connector>
  
                <!-- Connector for c array block -->
                <wbfk-connector class="connector--c-access-to-c-block c-related wbfk-hidden" b-marker></wbfk-connector>
  
                <!-- Connector for pointing down tree -->
                <wbfk-connector class="connector--down-tree wbfk-hidden" b-marker tracking-disabled></wbfk-connector>
  
                <!-- Connector for pointing up tree -->
                <wbfk-connector class="connector--up-tree wbfk-hidden" b-marker></wbfk-connector>
  
                <!-- Connector for connecting bullets -->
                <wbfk-connector class="connector--bullet-connector connector--dotted wbfk-hidden" tracking-disabled></wbfk-connector>
  
                <!-- BULLET -->
                <div class="job-card-bullet"></div>
  
                <!-- SJ NUM LABEL -->
                <div class="job-card-SJ-num-label">
                  <span class="SJ-num">X</span>
                </div>
    
                
                <!-- M CONTAINER -->
                <div class="M-container">
    
                  <span class="M-access-container">
                    <span class="M-access wbfk-hidden">
                      M[<span class="SJ-num">X</span>]
                    </span>
                    <span class="M-entry wbfk-hidden">X</span>
                  </span>
                </div>
            
  
                <!-- ARROW CONTAINER -->
                <div class="arrow-container wbfk-hidden">
                  <div class="arrow-head"></div>
                  <div class="arrow-tail"></div>
                </div>
            
                
                <!-- FORMULA CONTAINER -->
                <div class="formula-container">
                  <span class="formula-computation wbfk-hidden">
                    <!-- Max Container -->
                    <div class="max-container">
                      <span class="max-text">max</span>
                      <svg class="curly-brace" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 69.587 208.972">
                        <path
                          d="M26.421,178.356c0-17.982,1.674-34.019,1.674-51.272C28.1,117.122,23.444,107.4,0,107.4V101.57c23.444,0,28.1-9.719,28.1-19.682,0-15.551-1.674-34.748-1.674-51.271C26.421,6.561,37.771,0,60.656,0h8.931V5.346H58.424C36.654,5.346,32,13.851,32,31.589c0,14.822,1.3,31.832,1.3,47.626,0,13.365-3.163,21.869-15.443,24.785v.972c12.28,2.916,15.443,11.421,15.443,24.785,0,17.981-1.3,31.346-1.3,47.627,0,17.738,4.651,26.243,26.421,26.243H69.587v5.345H60.656C37.771,208.972,26.421,202.412,26.421,178.356Z" />
                      </svg>
                    </div>
                    <!-- Computations -->
                    <div class="computations-container">
                      <!-- Computation 1 -->
                      <div class="computation computation--1">
                        <span class="computation-expression computation-expression--1">
                          <span class="weight">X</span>
                          <span class="plus-sign">+</span>
                          <span class="OPT-expression-container">
                            <span class="OPT-expression">
                              OPT(<span class="c-access-container"><span class="c-access">c[<span class="SJ-num">X</span>]</span><span class="c-entry wbfk-hidden">X</span></span>)
                            </span>
                            <span class="OPT-result wbfk-hidden">X</span>
                          </span>
                        </span>
                        <span class="computation-result wbfk-hidden">X</span>
                      </div>
            
                      <!-- Computation 2 -->
                      <div class="computation computation--2">
                        <span class="OPT-expression-container">
                          <span class="OPT-expression">
                            OPT(<span class="next-SJ-num-container"><span class="next-SJ-num-expression"><span class="SJ-num">X</span>-1</span><span class="next-SJ-num wbfk-hidden">X</span></span>)
                          </span>
                          <span class="OPT-result wbfk-hidden">X</span>
                          <span class="computation-result wbfk-hidden">X</span>
                        </span>
                      </div>
                    </div>
                  </span>
  
                  <!-- Result -->
                  <span class="formula-result wbfk-hidden">X</span>
                </div>
              </div>
              
              <!--**************** JOB CARD CHILDREN ****************-->
              <div class="job-card-children">
                
              </div>
            </div>
          </template>
  
          <template id="job-stub-template">
            <div class="job-card job-card--stub wbfk-hidden" data-cardnum="X">
  
              <!--**************** CONTENT ****************-->
              <div class="job-card-content">
                <!-- TEXT BOXES -->
                <div class="text-boxes">
                  <!-- Text box: M Access -->
                  <div class="text-box-line-group text-box-line-group--M-access M-related">
                    <div class="text-box wbfk-hidden">
                      <p class="text-box__paragraph text-box__paragraph--1">
                        We need to know the optimal weight ending through <span class="SJ-related">job <span class="SJ-num">X</span></span>.
                        First, let's check the <span class="M-related">M array</span> to see if it has already been computed.
                      </p>
                      <p class="text-box__paragraph text-box__paragraph--2 wbfk-hidden">
                        The entry already exists. Of course, this is the base case for <span class="SJ-related">j = 0</span>. 0 jobs means 0 weight.
                        Let's pass this back up the tree.
                      </p>
                    </div>
                    <wbfk-connector class="wbfk-hidden"></wbfk-connector>
                  </div>
                </div>
  
                <!-- Connector for M array block -->
                <wbfk-connector class="connector--M-access-to-M-block M-related wbfk-hidden" b-marker></wbfk-connector>
  
                <!-- Connector for pointing up tree -->
                <wbfk-connector class="connector--up-tree wbfk-hidden" b-marker></wbfk-connector>
  
                <!-- Connector for connecting siblings -->
                <wbfk-connector class="connector--bullet-connector connector--dotted wbfk-hidden" tracking-disabled></wbfk-connector>
  
                <!-- SJ NUM LABEL -->
                <div class="job-card-SJ-num-label">
                  <span class="SJ-num">X</span>
                </div>
  
                <!-- BULLET -->
                <div class="job-card-bullet"></div>
  
                <!-- M CONTAINER -->
                <div class="M-container">
                  <span class="M-access-container">
                    <span class="M-access wbfk-hidden">
                      M[<span class="SJ-num">X</span>]
                    </span>
                    <span class="M-entry wbfk-hidden">X</span>
                  </span>
                </div>
              </div>
  
            </div>
          </template>
        
  
        
  
      </div>
  
      <div class="playback-buttons">
        <wbfk-playback-button action="step-backward" shortcut="ArrowLeft" allow-holding></wbfk-playback-button>
        <wbfk-playback-button action="pause" shortcut="Space"></wbfk-playback-button>
        <wbfk-playback-button action="step-forward" shortcut="ArrowRight" allow-holding></wbfk-playback-button>
        <wbfk-playback-button action="fast-forward" shortcut="F" trigger="hold"></wbfk-playback-button>
        <wbfk-playback-button action="toggle-skipping" shortcut="S"></wbfk-playback-button>
      </div>
    
    </div>

    </main>
</body>

</html>